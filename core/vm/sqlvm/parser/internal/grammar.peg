{
package internal

import (
	"github.com/dexon-foundation/dexon/core/vm/sqlvm/ast"
	se "github.com/dexon-foundation/dexon/core/vm/sqlvm/errors"
)
}

S
	<- _ x:Stmt? _ xs:( ';' _ s:Stmt? _ { return s, nil } )* EOF
{ return assertNodeSlice(prepend(x, assertSlice(xs))), nil }

/* Statements */
Stmt
	= SelectStmt
	/ UpdateStmt
	/ DeleteStmt
	/ InsertStmt
	/ CreateTableStmt
	/ CreateIndexStmt

SelectStmt
	= SelectToken
	_ f:SelectColumn fs:( _ SeparatorToken _ s:SelectColumn { return s, nil } )*
	table:( _ FromToken _ i:Identifier { return i, nil } )?
	where:( _ w:WhereClause { return w, nil } )?
	group:( _ g:GroupByClause { return g, nil } )?
	order:( _ or:OrderByClause { return or, nil } )?
	limit:( _ l:LimitClause { return l, nil } )?
	offset:( _ of:OffsetClause { return of, nil } )?
{
	node := &ast.SelectStmtNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.Column = assertExprSlice(prepend(f, assertSlice(fs)))
	if table != nil {
		node.Table = table.(*ast.IdentifierNode)
	}
	if where != nil {
		node.Where = where.(*ast.WhereOptionNode)
	}
	groupSlice := assertSlice(group)
	node.Group = make([]*ast.GroupOptionNode, len(groupSlice))
	for idx := range groupSlice {
		node.Group[idx] = groupSlice[idx].(*ast.GroupOptionNode)
	}
	orderSlice := assertSlice(order)
	node.Order = make([]*ast.OrderOptionNode, len(orderSlice))
	for idx := range orderSlice {
		node.Order[idx] = orderSlice[idx].(*ast.OrderOptionNode)
	}
	if limit != nil {
		node.Limit = limit.(*ast.LimitOptionNode)
	}
	if offset != nil {
		node.Offset = offset.(*ast.OffsetOptionNode)
	}
	return node, nil
}

SelectColumn
	= AnyLiteral
	/ Expr

UpdateStmt
	= UpdateToken
	_ table:Identifier
	_ SetToken
	_ a:Assignment as:( _ SeparatorToken _ s:Assignment { return s, nil } )*
	where:( _ w:WhereClause { return w, nil } )?
{
	node := &ast.UpdateStmtNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.Table = table.(*ast.IdentifierNode)
	assignSlice := prepend(a, assertSlice(as))
	node.Assignment = make([]*ast.AssignOperatorNode, len(assignSlice))
	for idx := range assignSlice {
		node.Assignment[idx] = assignSlice[idx].(*ast.AssignOperatorNode)
	}
	if where != nil {
		node.Where = where.(*ast.WhereOptionNode)
	}
	return node, nil
}

DeleteStmt
	= DeleteToken
	_ FromToken
	_ table:Identifier
	where:( _ w:WhereClause { return w, nil } )?
{
	node := &ast.DeleteStmtNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.Table = table.(*ast.IdentifierNode)
	if where != nil {
		node.Where = where.(*ast.WhereOptionNode)
	}
	return node, nil
}

InsertStmt
	= InsertToken
	_ IntoToken
	_ table:Identifier
	_ insert:( InsertWithColumnClause / InsertWithDefaultClause )
{
	node := &ast.InsertStmtNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.Table = table.(*ast.IdentifierNode)
	switch i := insert.(type) {
	case *ast.InsertWithColumnOptionNode:
		node.Insert = i
	case *ast.InsertWithDefaultOptionNode:
		node.Insert = i
	default:
		panic(fmt.Sprintf("unknown insert type %T", insert))
	}
	return node, nil
}

InsertValue
	= '(' _ e:MultiExprWithDefault _ ')'
{ return e, nil }

CreateTableStmt
	= CreateToken
	_ TableToken
	_ table:Identifier
	_ '('
	_ column:(
		s:ColumnSchema
		ss:( _ SeparatorToken _ t:ColumnSchema { return t, nil } )*
		{ return prepend(s, assertSlice(ss)), nil }
	)?
	_ ')'
{
	node := &ast.CreateTableStmtNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.Table = table.(*ast.IdentifierNode)
	columnSlice := assertSlice(column)
	node.Column = make([]*ast.ColumnSchemaNode, len(columnSlice))
	for idx := range columnSlice {
		node.Column[idx] = columnSlice[idx].(*ast.ColumnSchemaNode)
	}
	return node, nil
}

ColumnSchema
	= i:Identifier
	_ t:DataType
	cs:( _ s:ColumnConstraint { return s, nil } )*
{
	node := &ast.ColumnSchemaNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.Column = i.(*ast.IdentifierNode)
	node.DataType = t.(ast.TypeNode)
	constraintSlice := assertSlice(cs)
	node.Constraint = make([]ast.Node, len(constraintSlice))
	for idx, constraint := range constraintSlice {
		switch c := constraint.(type) {
		case *ast.PrimaryOptionNode:
			node.Constraint[idx] = c
		case *ast.NotNullOptionNode:
			node.Constraint[idx] = c
		case *ast.UniqueOptionNode:
			node.Constraint[idx] = c
		case *ast.DefaultOptionNode:
			node.Constraint[idx] = c
		case *ast.ForeignOptionNode:
			node.Constraint[idx] = c
		case *ast.AutoIncrementOptionNode:
			node.Constraint[idx] = c
		default:
			panic(fmt.Sprintf("unknown constraint type %T", c))
		}
	}
	return node, nil
}

ColumnConstraint
	= PrimaryKeyClause
	/ NotNullClause
	/ UniqueClause
	/ DefaultClause
	/ ForeignClause
	/ AutoincrementClause

CreateIndexStmt
	= CreateToken
	unique:( _ u:UniqueClause { return u, nil } )?
	_ IndexToken
	_ index:Identifier
	_ OnToken
	_ table:Identifier
	_ '(' _ i:Identifier is:( _ SeparatorToken _ x:Identifier { return x, nil } )* _ ')'
{
	node := &ast.CreateIndexStmtNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.Index = index.(*ast.IdentifierNode)
	node.Table = table.(*ast.IdentifierNode)
	columnSlice := assertSlice(prepend(i, assertSlice(is)))
	node.Column = make([]*ast.IdentifierNode, len(columnSlice))
	for idx := range columnSlice {
		node.Column[idx] = columnSlice[idx].(*ast.IdentifierNode)
	}
	if unique != nil {
		node.Unique = unique.(*ast.UniqueOptionNode)
	}
	return node, nil
}

/* Clauses */
WhereClause
	= WhereToken _ e:Expr
{
	node := &ast.WhereOptionNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.Condition = e.(ast.ExprNode)
	return node, nil
}

OrderByClause
	= OrderToken
	_ ByToken
	_ f:OrderColumn
	fs:( _ SeparatorToken _ s:OrderColumn { return s, nil } )*
{
	return prepend(f, assertSlice(fs)), nil
}

OrderColumn
	= i:Expr
	s:( _ t:( AscToken / DescToken ) { return t, nil } )?
	n:( _ NullsToken _ l:( LastToken / FirstToken ) { return l, nil } )?
{
	node := &ast.OrderOptionNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.Expr = i.(ast.ExprNode)
	node.Desc = s != nil && string(s.([]byte)) == "desc"
	node.NullsFirst = n != nil && string(n.([]byte)) == "first"
	return node, nil
}

GroupByClause
	= GroupToken
	_ ByToken
	_ f:GroupColumn
	fs:( _ SeparatorToken _ s:GroupColumn { return s, nil } )*
{
	return prepend(f, assertSlice(fs)), nil
}

GroupColumn
	= i:Expr
{
	node := &ast.GroupOptionNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.Expr = i.(ast.ExprNode)
	return node, nil
}

OffsetClause
	= OffsetToken _ i:Integer
{
	node := &ast.OffsetOptionNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.Value = i.(*ast.IntegerValueNode)
	return node, nil
}

LimitClause
	= LimitToken _ i:Integer
{
	node := &ast.LimitOptionNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.Value = i.(*ast.IntegerValueNode)
	return node, nil
}

InsertWithColumnClause
	= cs:( '('
			_ f:Identifier
			fs:( _ SeparatorToken _ x:Identifier { return x, nil } )*
			_ ')'
			_ { return prepend(f, assertSlice(fs)), nil }
		)?
		ValuesToken
	_ v:InsertValue
	vs:( _ SeparatorToken _ y:InsertValue { return y, nil } )*
{
	node := &ast.InsertWithColumnOptionNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	columnSlice := assertSlice(cs)
	node.Column = make([]*ast.IdentifierNode, len(columnSlice))
	for idx := range columnSlice {
		node.Column[idx] = columnSlice[idx].(*ast.IdentifierNode)
	}
	valueSlice := assertSlice(vs)
	node.Value = make([][]ast.ExprNode, len(valueSlice)+1)
	node.Value[0] = v.([]ast.ExprNode)
	for idx := range valueSlice {
		node.Value[idx+1] = valueSlice[idx].([]ast.ExprNode)
	}
	return node, nil
}

InsertWithDefaultClause
	= DefaultToken _ ValuesToken
{
	node := &ast.InsertWithDefaultOptionNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	return node, nil
}

PrimaryKeyClause
	= PrimaryToken _ KeyToken
{
	node := &ast.PrimaryOptionNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	return node, nil
}

NotNullClause
	= NotToken _ NullToken
{
	node := &ast.NotNullOptionNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	return node, nil
}

UniqueClause
	= UniqueToken
{
	node := &ast.UniqueOptionNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	return node, nil
}

DefaultClause
	= DefaultToken _ e:Expr
{
	node := &ast.DefaultOptionNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.Value = e.(ast.ExprNode)
	return node, nil
}

ForeignClause
	= ReferencesToken _ t:Identifier _ '(' _ f:Identifier _ ')'
{
	node := &ast.ForeignOptionNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.Table = t.(*ast.IdentifierNode)
	node.Column = f.(*ast.IdentifierNode)
	return node, nil
}

AutoincrementClause
	= AutoincrementToken
{
	node := &ast.AutoIncrementOptionNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	return node, nil
}

/* Expressions */
Expr
	= LogicExpr

ExprWithDefault
	= &(DefaultLiteral) d:DefaultLiteral { return d, nil }
	/ Expr

LogicExpr
	= LogicExpr4

LogicExpr4
	= o:LogicExpr3
		os:( _ op:OrOperator _ s:LogicExpr3
		{ return opSetSubject(op.(ast.BinaryOperator), s.(ast.ExprNode)), nil } )*
{ return rightJoinOperators(o.(ast.ExprNode), assertExprSlice(os)), nil }

LogicExpr3
	= o:LogicExpr2
		os:( _ op:AndOperator _ s:LogicExpr2
		{ return opSetSubject(op.(ast.BinaryOperator), s.(ast.ExprNode)), nil } )*
{ return rightJoinOperators(o.(ast.ExprNode), assertExprSlice(os)), nil }

LogicExpr2
	= op:NotOperator _ s:LogicExpr2
	{ return opSetTarget(op.(ast.UnaryOperator), s.(ast.ExprNode)), nil }
	/ LogicExpr1

LogicExpr1
	= o:ArithmeticExpr os:( _ l:LogicExpr1Op { return l, nil } )*
{ return rightJoinOperators(o.(ast.ExprNode), assertExprSlice(os)), nil }

LogicExpr1Op
	= LogicExpr1In
	/ LogicExpr1Is
	/ LogicExpr1Like
	/ LogicExpr1Cmp

LogicExpr1In
	= n:( t:NotOperator _ { return t, nil } )? InToken _ '(' _ s:MultiExpr _ ')'
{
	node := &ast.InOperatorNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.Right = s.([]ast.ExprNode)
	if n != nil {
		return opSetTarget(n.(ast.UnaryOperator), node), nil
	}
	return node, nil
}

LogicExpr1Is
	= IsToken n:( _ t:NotOperator { return t, nil } )? _ u:NullLiteral
{
	node := &ast.IsOperatorNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	opSetSubject(node, u.(*ast.NullValueNode))
	if n != nil {
		return opSetTarget(n.(ast.UnaryOperator), node), nil
	}
	return node, nil
}

LogicExpr1Like
	= n:( t:NotOperator _ { return t, nil } )? LikeToken _ s:Expr
	escape:( _ EscapeToken _ e:Expr { return e, nil } )?
{
	node := &ast.LikeOperatorNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	opSetSubject(node, s.(ast.ExprNode))
	if escape != nil {
		node.Escape = escape.(ast.ExprNode)
	}
	if n != nil {
		return opSetTarget(n.(ast.UnaryOperator), node), nil
	}
	return node, nil
}

LogicExpr1Cmp
	= op:CmpOperator _ s:ArithmeticExpr
{ return opSetSubject(op.(ast.BinaryOperator), s.(ast.ExprNode)), nil }

ArithmeticExpr
	= ArithmeticExpr3

ArithmeticExpr3
	= o:ArithmeticExpr2
		os:( _ op:ConcatOperator _ s:ArithmeticExpr2
		{ return opSetSubject(op.(ast.BinaryOperator), s.(ast.ExprNode)), nil } )*
{ return rightJoinOperators(o.(ast.ExprNode), assertExprSlice(os)), nil }

ArithmeticExpr2
	= o:ArithmeticExpr1
		os:( _ op:AddSubOperator _ s:ArithmeticExpr1
		{ return opSetSubject(op.(ast.BinaryOperator), s.(ast.ExprNode)), nil } )*
{ return rightJoinOperators(o.(ast.ExprNode), assertExprSlice(os)), nil }

ArithmeticExpr1
	= o:Operand
		os:( _ op:MulDivModOperator _ s:Operand
		{ return opSetSubject(op.(ast.BinaryOperator), s.(ast.ExprNode)), nil } )*
{ return rightJoinOperators(o.(ast.ExprNode), assertExprSlice(os)), nil }

MultiExpr
	= x:Expr xs:( _ SeparatorToken _ e:Expr { return e, nil } )*
{ return assertExprSlice(prepend(x, assertSlice(xs))), nil }

MultiExprWithDefault
	= x:ExprWithDefault xs:( _ SeparatorToken _ e:ExprWithDefault { return e, nil } )*
{ return assertExprSlice(prepend(x, assertSlice(xs))), nil }

Operand
	= op:UnaryOperator _ s:Operand
		{ return opSetTarget(op.(ast.UnaryOperator), s.(ast.ExprNode)), nil }
	/ '(' _ e:Expr _ ')'
		{
			node := &ast.ParenOperatorNode{}
			node.SetPosition(uint32(c.pos.offset))
			node.SetLength(uint32(len(c.text)))
			opSetTarget(node, e.(ast.ExprNode))
			return node, nil
		}
	/ &(CastToken) t:TypeCast { return t, nil }
	/ FunctionCall
	/ Value
	/ Identifier

TypeCast
	= CastToken _ '(' _ o:Expr _ AsToken _ s:DataType _ ')'
{
	node := &ast.CastOperatorNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.SourceExpr = o.(ast.ExprNode)
	node.TargetType = s.(ast.TypeNode)
	return node, nil
}

FunctionCall
	= i:Identifier _ '(' _ r:FunctionArgs? _ ')'
{
	node := &ast.FunctionOperatorNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.Name = i.(*ast.IdentifierNode)
	if r != nil {
		node.Args = r.([]ast.ExprNode)
	}
	return node, nil
}

FunctionArgs
	= a:AnyLiteral { return []ast.ExprNode{a.(*ast.AnyValueNode)}, nil }
	/ MultiExpr

Assignment
	= i:Identifier _ '=' _ e:ExprWithDefault
{
	node := &ast.AssignOperatorNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.Column = i.(*ast.IdentifierNode)
	node.Expr = e.(ast.ExprNode)
	return node, nil
}

/* Operators */
UnaryOperator
	= SignOperator

SignOperator
	= Sign
{
	var node ast.UnaryOperator
	switch string(c.text) {
	case "+":
		node = &ast.PosOperatorNode{}
	case "-":
		node = &ast.NegOperatorNode{}
	default:
		panic(fmt.Sprintf("unknown sign %s", c.text))
	}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	return node, nil
}

NotOperator
	= NotToken
{
	node := &ast.NotOperatorNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	return node, nil
}

AndOperator
	= AndToken
{
	node := &ast.AndOperatorNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	return node, nil
}

OrOperator
	= OrToken
{
	node := &ast.OrOperatorNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	return node, nil
}

CmpOperator
	= ( "<=" / ">=" / "<>" / "!=" / [<>=] )
{
	var node ast.BinaryOperator
	switch string(c.text) {
	case "<=":
		node = &ast.LessOrEqualOperatorNode{}
	case ">=":
		node = &ast.GreaterOrEqualOperatorNode{}
	case "<>":
		node = &ast.NotEqualOperatorNode{}
	case "!=":
		node = &ast.NotEqualOperatorNode{}
	case "<":
		node = &ast.LessOperatorNode{}
	case ">":
		node = &ast.GreaterOperatorNode{}
	case "=":
		node = &ast.EqualOperatorNode{}
	default:
		panic(fmt.Sprintf("unknown comparison operator %s", c.text))
	}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	return node, nil
}

ConcatOperator
	= "||"
{
	node := &ast.ConcatOperatorNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	return node, nil
}

AddSubOperator
	= [+-]
{
	var node ast.BinaryOperator
	switch string(c.text) {
	case "+":
		node = &ast.AddOperatorNode{}
	case "-":
		node = &ast.SubOperatorNode{}
	default:
		panic(fmt.Sprintf("unknown addition or subtraction operator %s", c.text))
	}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	return node, nil
}

MulDivModOperator
	= [*/%]
{
	var node ast.BinaryOperator
	switch string(c.text) {
	case "*":
		node = &ast.MulOperatorNode{}
	case "/":
		node = &ast.DivOperatorNode{}
	case "%":
		node = &ast.ModOperatorNode{}
	default:
		panic(fmt.Sprintf("unknown multiplication, division, modulo operator: %s", c.text))
	}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	return node, nil
}

/* Types */
DataType
	= UIntType
	/ IntType
	/ UFixedType
	/ FixedType
	/ FixedBytesType
	/ DynamicBytesType
	/ BoolType
	/ AddressType

UIntType
	= "UINT"i s:NonZeroLeadingInteger !NormalIdentifierRest
{
	node := &ast.IntTypeNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.Unsigned = true
	size, code := toUint(s.([]byte))
	if code != se.ErrorCodeNil {
		err := se.Error{
			Position: uint32(c.pos.offset),
			Length:   uint32(len(c.text)),
			Category: se.ErrorCategoryGrammar,
			Code:     code,
			Token:    string(c.text),
			Prefix:   "UIntType",
			Message:  fmt.Sprintf("cannot parse %s as uint32: %v", s, code),
		}
		return node, err
	}
	node.Size = size
	return node, nil
}

IntType
	= "INT"i s:NonZeroLeadingInteger !NormalIdentifierRest
{
	node := &ast.IntTypeNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.Unsigned = false
	size, code := toUint(s.([]byte))
	if code != se.ErrorCodeNil {
		err := se.Error{
			Position: uint32(c.pos.offset),
			Length:   uint32(len(c.text)),
			Category: se.ErrorCategoryGrammar,
			Code:     code,
			Token:    string(c.text),
			Prefix:   "IntType",
			Message:  fmt.Sprintf("cannot parse %s as uint32: %v", s, code),
		}
		return node, err
	}
	node.Size = size
	return node, nil
}

UFixedType
	= "UFIXED"i s:NonZeroLeadingInteger "X"i t:NonZeroLeadingInteger !NormalIdentifierRest
{
	node := &ast.FixedTypeNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.Unsigned = true
	size, code := toUint(s.([]byte))
	if code != se.ErrorCodeNil {
		err := se.Error{
			Position: uint32(c.pos.offset),
			Length:   uint32(len(c.text)),
			Category: se.ErrorCategoryGrammar,
			Code:     code,
			Token:    string(c.text),
			Prefix:   "UFixedType",
			Message:  fmt.Sprintf("cannot parse %s as uint32: %v", s, code),
		}
		return node, err
	}
	fractionalDigits, code := toUint(t.([]byte))
	if code != se.ErrorCodeNil {
		err := se.Error{
			Position: uint32(c.pos.offset),
			Length:   uint32(len(c.text)),
			Category: se.ErrorCategoryGrammar,
			Code:     code,
			Token:    string(c.text),
			Prefix:   "UFixedType",
			Message:  fmt.Sprintf("cannot parse %s as uint32: %v", t, code),
		}
		return node, err
	}
	node.Size = size
	node.FractionalDigits = fractionalDigits
	return node, nil
}

FixedType
	= "FIXED"i s:NonZeroLeadingInteger "X"i t:NonZeroLeadingInteger !NormalIdentifierRest
{
	node := &ast.FixedTypeNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.Unsigned = false
	size, code := toUint(s.([]byte))
	if code != se.ErrorCodeNil {
		err := se.Error{
			Position: uint32(c.pos.offset),
			Length:   uint32(len(c.text)),
			Category: se.ErrorCategoryGrammar,
			Code:     code,
			Token:    string(c.text),
			Prefix:   "FixedType",
			Message:  fmt.Sprintf("cannot parse %s as uint32: %v", s, code),
		}
		return node, err
	}
	fractionalDigits, code := toUint(t.([]byte))
	if code != se.ErrorCodeNil {
		err := se.Error{
			Position: uint32(c.pos.offset),
			Length:   uint32(len(c.text)),
			Category: se.ErrorCategoryGrammar,
			Code:     code,
			Token:    string(c.text),
			Prefix:   "FixedType",
			Message:  fmt.Sprintf("cannot parse %s as uint32: %v", t, code),
		}
		return node, err
	}
	node.Size = size
	node.FractionalDigits = fractionalDigits
	return node, nil
}

FixedBytesType
	= "BYTES"i s:NonZeroLeadingInteger !NormalIdentifierRest
{
	node := &ast.FixedBytesTypeNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	size, code := toUint(s.([]byte))
	if code != se.ErrorCodeNil {
		err := se.Error{
			Position: uint32(c.pos.offset),
			Length:   uint32(len(c.text)),
			Category: se.ErrorCategoryGrammar,
			Code:     code,
			Token:    string(c.text),
			Prefix:   "FixedBytesType",
			Message:  fmt.Sprintf("cannot parse %s as uint32: %v", s, code),
		}
		return node, err
	}
	node.Size = size
	return node, nil
}
	/ "BYTE"i !NormalIdentifierRest
{
	node := &ast.FixedBytesTypeNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.Size = 1
	return node, nil
}

DynamicBytesType
	= ( "BYTES"i !NormalIdentifierRest
		/ "STRING"i !NormalIdentifierRest
		/ "TEXT"i !NormalIdentifierRest
	)
{
	node := &ast.DynamicBytesTypeNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	return node, nil
}

AddressType
	= "ADDRESS"i !NormalIdentifierRest
{
	node := &ast.AddressTypeNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	return node, nil
}

BoolType
	= ( "BOOL"i !NormalIdentifierRest
		/ "BOOLEAN"i !NormalIdentifierRest
	)
{
	node := &ast.BoolTypeNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	return node, nil
}

/* Values */
Value
	= NumberLiteral
	/ StringLiteral
	/ BoolLiteral
	/ NullLiteral

AnyLiteral
	= AnyToken
{
	node := &ast.AnyValueNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	return node, nil
}

DefaultLiteral
	= DefaultToken
{
	node := &ast.DefaultValueNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	return node, nil
}

BoolLiteral
	= b:( TrueToken / FalseToken )
{
	node := &ast.BoolValueNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.V = string(b.([]byte)) == "true"
	return node, nil
}

NullLiteral
	= NullToken
{
	node := &ast.NullValueNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	return node, nil
}

NumberLiteral
	= &("0" "X"i) h:Hex { return h, nil }
	/ Decimal

Sign
	= [-+]

Integer
	= [0-9]+
{
	node := &ast.IntegerValueNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.IsAddress = false
	v, code := toDecimal(c.text)
	if code != se.ErrorCodeNil {
		err := se.Error{
			Position: uint32(c.pos.offset),
			Length:   uint32(len(c.text)),
			Category: se.ErrorCategoryGrammar,
			Code:     code,
			Token:    string(c.text),
			Prefix:   "Integer",
			Message:  fmt.Sprintf("cannot parse %s as decimal: %v", c.text, code),
		}
		return node, err
	}
	node.V = v
	return node, nil
}

NonZeroLeadingInteger
	= ( "0" / [1-9][0-9]* )
{ return c.text, nil }

Fixnum
	= Integer "." Integer
	/ Integer "."?
	/ "." Integer

Decimal
	= Fixnum ( "E"i Sign? Integer )?
{
	node := &ast.DecimalValueNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	v, code := toDecimal(c.text)
	if code != se.ErrorCodeNil {
		err := se.Error{
			Position: uint32(c.pos.offset),
			Length:   uint32(len(c.text)),
			Category: se.ErrorCategoryGrammar,
			Code:     code,
			Token:    string(c.text),
			Prefix:   "Decimal",
			Message:  fmt.Sprintf("cannot parse %s as decimal: %v", c.text, code),
		}
		return node, err
	}
	node.V = v
	return node, nil
}

Hex
	= "0x" ( [0-9A-Fa-f] )+ !NormalIdentifierRest
{
	node := hexToInteger(c.text)
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	return node, nil
}

StringLiteral
	= HexString
	/ NormalString

HexString
	= ( "HEX"i / "X"i ) "'" s:([0-9a-fA-F][0-9a-fA-F] { return c.text, nil } )* "'"
{
	node := &ast.BytesValueNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.V = hexToBytes(joinBytes(assertSlice(s)))
	return node, nil
}

NormalString
	= "'" s:( ( [^'\r\n\\] / "\\" . ) { return c.text, nil } )* "'"
{
	node := &ast.BytesValueNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	bs := joinBytes(assertSlice(s))
	v, bad, code := resolveString(bs)
	if code != se.ErrorCodeNil {
		msg := fmt.Sprintf("cannot resolve escape sequence '%s': %v",
			sanitizeBadEscape(bad), code)
		err := se.Error{
			Position: uint32(c.pos.offset),
			Length:   uint32(len(c.text)),
			Category: se.ErrorCategoryGrammar,
			Code:     code,
			Token:    string(c.text),
			Prefix:   "NormalString",
			Message:  msg,
		}
		return node, err
	}
	node.V = v
	return node, nil
}

/* Tokens */
SelectToken
	= "SELECT"i !NormalIdentifierRest

FromToken
	= "FROM"i !NormalIdentifierRest

WhereToken
	= "WHERE"i !NormalIdentifierRest

OrderToken
	= "ORDER"i !NormalIdentifierRest

ByToken
	= "BY"i !NormalIdentifierRest

GroupToken
	= "GROUP"i !NormalIdentifierRest

LimitToken
	= "LIMIT"i !NormalIdentifierRest

OffsetToken
	= "OFFSET"i !NormalIdentifierRest

UpdateToken
	= "UPDATE"i !NormalIdentifierRest

SetToken
	= "SET"i !NormalIdentifierRest

DeleteToken
	= "DELETE"i !NormalIdentifierRest

InsertToken
	= "INSERT"i !NormalIdentifierRest

IntoToken
	= "INTO"i !NormalIdentifierRest

ValuesToken
	= "VALUES"i !NormalIdentifierRest

CreateToken
	= "CREATE"i !NormalIdentifierRest

TableToken
	= "TABLE"i !NormalIdentifierRest

IndexToken
	= "INDEX"i !NormalIdentifierRest

UniqueToken
	= "UNIQUE"i !NormalIdentifierRest

DefaultToken
	= "DEFAULT"i !NormalIdentifierRest

PrimaryToken
	= "PRIMARY"i !NormalIdentifierRest

KeyToken
	= "KEY"i !NormalIdentifierRest

ReferencesToken
	= "REFERENCES"i !NormalIdentifierRest

AutoincrementToken
	= "AUTOINCREMENT"i !NormalIdentifierRest

OnToken
	= "ON"i !NormalIdentifierRest

TrueToken
	= "TRUE"i !NormalIdentifierRest
{ return toLower(c.text), nil }

FalseToken
	= "FALSE"i !NormalIdentifierRest
{ return toLower(c.text), nil }

NullToken
	= "NULL"i !NormalIdentifierRest

IsToken
	= "IS"i !NormalIdentifierRest

NullsToken
	= "NULLS"i !NormalIdentifierRest

LastToken
	= "LAST"i !NormalIdentifierRest
{ return toLower(c.text), nil }

FirstToken
	= "FIRST"i !NormalIdentifierRest
{ return toLower(c.text), nil }

AndToken
	= "AND"i !NormalIdentifierRest

OrToken
	= "OR"i !NormalIdentifierRest

NotToken
	= "NOT"i !NormalIdentifierRest

InToken
	= "IN"i !NormalIdentifierRest

LikeToken
	= "LIKE"i !NormalIdentifierRest

EscapeToken
	= "ESCAPE"i !NormalIdentifierRest

AscToken
	= "ASC"i !NormalIdentifierRest
{ return toLower(c.text), nil }

DescToken
	= "DESC"i !NormalIdentifierRest
{ return toLower(c.text), nil }

CastToken
	= "CAST"i !NormalIdentifierRest

AsToken
	= "AS"i !NormalIdentifierRest

SeparatorToken
	= ","

AnyToken
	= "*"

/* Identifiers */
Identifier
	= NormalIdentifier
	/ StringIdentifier

NormalIdentifier
	= NormalIdentifierStart NormalIdentifierRest*
{
	node := &ast.IdentifierNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.Name = decodeString(c.text)
	return node, nil
}

NormalIdentifierStart
	= [a-zA-Z\x80-\xff]

NormalIdentifierRest
	= [a-zA-Z0-9_\x80-\xff]

StringIdentifier
	= "\"" s:( ( [^"\r\n\\] / "\\" . ) { return c.text, nil } )* "\""
{
	node := &ast.IdentifierNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	bs := joinBytes(assertSlice(s))
	name, bad, code := resolveString(bs)
	if code != se.ErrorCodeNil {
		msg := fmt.Sprintf("cannot resolve escape sequence '%s': %v",
			sanitizeBadEscape(bad), code)
		err := se.Error{
			Position: uint32(c.pos.offset),
			Length:   uint32(len(c.text)),
			Category: se.ErrorCategoryGrammar,
			Code:     code,
			Token:    string(c.text),
			Prefix:   "StringIdentifier",
			Message:  msg,
		}
		return node, err
	}
	node.Name = name
	return node, nil
}

/* Skip */
_
	= Whitespace*

Whitespace
	= "\t" // \x09 (HT)
	/ "\n" // \x0a (LF)
	/ "\v" // \x0b (VT)
	/ "\f" // \x0c (FF)
	/ "\r" // \x0d (CR)
	/ " "  // \x20 (SPACE)

EOF
	= !.
