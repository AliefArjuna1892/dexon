{
package parser

import (
	"github.com/dexon-foundation/dexon/core/vm/sqlvm/ast"
	"github.com/dexon-foundation/dexon/core/vm/sqlvm/errors"
)
}

S
	<- _ x:Stmt? _ xs:( ';' _ s:Stmt? _ { return s, nil } )* EOF
{ return prepend(x, xs), nil }

/* Statements */
Stmt
	= SelectStmt
	/ UpdateStmt
	/ DeleteStmt
	/ InsertStmt
	/ CreateTableStmt
	/ CreateIndexStmt

SelectStmt
	= SelectToken
	_ f:SelectColumn fs:( _ SeparatorToken _ s:SelectColumn { return s, nil } )*
	table:( _ FromToken _ i:Identifier { return i, nil } )?
	where:( _ w:WhereClause { return w, nil } )?
	group:( _ g:GroupByClause { return g, nil } )?
	order:( _ or:OrderByClause { return or, nil } )?
	limit:( _ l:LimitClause { return l, nil } )?
	offset:( _ of:OffsetClause { return of, nil } )?
{
	var (
		tableNode  *ast.IdentifierNode
		whereNode  *ast.WhereOptionNode
		limitNode  *ast.LimitOptionNode
		offsetNode *ast.OffsetOptionNode
	)
	if table != nil {
		t := table.(ast.IdentifierNode)
		tableNode = &t
	}
	if where != nil {
		w := where.(ast.WhereOptionNode)
		whereNode = &w
	}
	if limit != nil {
		l := limit.(ast.LimitOptionNode)
		limitNode = &l
	}
	if offset != nil {
		o := offset.(ast.OffsetOptionNode)
		offsetNode = &o
	}
	return ast.SelectStmtNode{
		Column: prepend(f, fs),
		Table:  tableNode,
		Where:  whereNode,
		Group:  toSlice(group),
		Order:  toSlice(order),
		Limit:  limitNode,
		Offset: offsetNode,
	}, nil
}

SelectColumn
	= AnyLiteral
	/ Expr

UpdateStmt
	= UpdateToken
	_ table:Identifier
	_ SetToken
	_ a:Assignment as:( _ SeparatorToken _ s:Assignment { return s, nil } )*
	where:( _ w:WhereClause { return w, nil } )?
{
	var (
		whereNode *ast.WhereOptionNode
	)
	if where != nil {
		w := where.(ast.WhereOptionNode)
		whereNode = &w
	}
	return ast.UpdateStmtNode{
		Table:      table.(ast.IdentifierNode),
		Assignment: prepend(a, as),
		Where:      whereNode,
	}, nil
}

DeleteStmt
	= DeleteToken
	_ FromToken
	_ table:Identifier
	where:( _ w:WhereClause { return w, nil } )?
{
	var (
		whereNode *ast.WhereOptionNode
	)
	if where != nil {
		w := where.(ast.WhereOptionNode)
		whereNode = &w
	}
	return ast.DeleteStmtNode{
		Table: table.(ast.IdentifierNode),
		Where: whereNode,
	}, nil
}

InsertStmt
	= InsertToken
	_ IntoToken
	_ table:Identifier
	_ insert:( InsertWithColumnClause / InsertWithDefaultClause )
{
	return ast.InsertStmtNode{
		Table:  table.(ast.IdentifierNode),
		Insert: insert,
	}, nil
}

InsertValue
	= '(' _ e:MultiExprWithDefault _ ')'
{ return e, nil }

CreateTableStmt
	= CreateToken
	_ TableToken
	_ table:Identifier
	_ '('
	_ column:(
		s:ColumnSchema
		ss:( _ SeparatorToken _ t:ColumnSchema { return t, nil } )*
		{ return prepend(s, ss), nil }
	)?
	_ ')'
{
	return ast.CreateTableStmtNode{
		Table:  table.(ast.IdentifierNode),
		Column: toSlice(column),
	}, nil
}

ColumnSchema
	= i:Identifier
	_ t:DataType
	cs:( _ s:ColumnConstraint { return s, nil } )*
{
	return ast.ColumnSchemaNode{
		Column:     i.(ast.IdentifierNode),
		DataType:   t,
		Constraint: toSlice(cs),
	}, nil
}

ColumnConstraint
	= PrimaryKeyClause
	/ NotNullClause
	/ UniqueClause
	/ DefaultClause
	/ ForeignClause
	/ AutoincrementClause

CreateIndexStmt
	= CreateToken
	unique:( _ u:UniqueClause { return u, nil } )?
	_ IndexToken
	_ index:Identifier
	_ OnToken
	_ table:Identifier
	_ '(' _ i:Identifier is:( _ SeparatorToken _ x:Identifier { return x, nil } )* _ ')'
{
	var (
		uniqueNode *ast.UniqueOptionNode
	)
	if unique != nil {
		u := unique.(ast.UniqueOptionNode)
		uniqueNode = &u
	}
	return ast.CreateIndexStmtNode{
		Index:  index.(ast.IdentifierNode),
		Table:  table.(ast.IdentifierNode),
		Column: prepend(i, is),
		Unique: uniqueNode,
	}, nil
}

/* Clauses */
WhereClause
	= WhereToken _ e:Expr
{ return ast.WhereOptionNode{Condition: e}, nil }

OrderByClause
	= OrderToken
	_ ByToken
	_ f:OrderColumn
	fs:( _ SeparatorToken _ s:OrderColumn { return s, nil } )*
{ return prepend(f, fs), nil }

OrderColumn
	= i:Expr
	s:( _ t:( AscToken / DescToken ) { return t, nil } )?
	n:( _ NullsToken _ l:( LastToken / FirstToken ) { return l, nil } )?
{
	return ast.OrderOptionNode{
		Expr:       i,
		Desc:       s != nil && string(s.([]byte)) == "desc",
		NullsFirst: n != nil && string(n.([]byte)) == "first",
	}, nil
}

GroupByClause
	= GroupToken
	_ ByToken
	_ i:Expr
	is:( _ SeparatorToken _ s:Expr { return ast.GroupOptionNode{Expr: s}, nil } )*
{ return prepend(ast.GroupOptionNode{Expr: i}, is), nil }

OffsetClause
	= OffsetToken _ i:Integer
{ return ast.OffsetOptionNode{Value: i.(ast.IntegerValueNode)}, nil }

LimitClause
	= LimitToken _ i:Integer
{ return ast.LimitOptionNode{Value: i.(ast.IntegerValueNode)}, nil }

InsertWithColumnClause
	= cs:( '('
			_ f:Identifier
			fs:( _ SeparatorToken _ x:Identifier { return x, nil } )*
			_ ')'
			_ { return prepend(f, fs), nil }
		)?
		ValuesToken
	_ v:InsertValue
	vs:( _ SeparatorToken _ y:InsertValue { return y, nil } )*
{
	return ast.InsertWithColumnOptionNode{
		Column: toSlice(cs),
		Value:  prepend(v, vs),
	}, nil
}

InsertWithDefaultClause
	= DefaultToken _ ValuesToken
{ return ast.InsertWithDefaultOptionNode{}, nil }

PrimaryKeyClause
	= PrimaryToken _ KeyToken
{ return ast.PrimaryOptionNode{}, nil }

NotNullClause
	= NotToken _ NullToken
{ return ast.NotNullOptionNode{}, nil }

UniqueClause
	= UniqueToken
{ return ast.UniqueOptionNode{}, nil }

DefaultClause
	= DefaultToken _ e:Expr
{ return ast.DefaultOptionNode{Value: e}, nil }

ForeignClause
	= ReferencesToken _ t:Identifier _ '(' _ f:Identifier _ ')'
{
	return ast.ForeignOptionNode{
		Table:  t.(ast.IdentifierNode),
		Column: f.(ast.IdentifierNode),
	}, nil
}

AutoincrementClause
	= AutoincrementToken
{ return ast.AutoIncrementOptionNode{}, nil }

/* Expressions */
Expr
	= LogicExpr

ExprWithDefault
	= &(DefaultLiteral) d:DefaultLiteral { return d, nil }
	/ Expr

LogicExpr
	= LogicExpr4

LogicExpr4
	= o:LogicExpr3
		os:( _ op:OrOperator _ s:LogicExpr3 { return opSetSubject(op, s), nil } )*
{ return rightJoinOperators(o, os), nil }

LogicExpr3
	= o:LogicExpr2
		os:( _ op:AndOperator _ s:LogicExpr2 { return opSetSubject(op, s), nil } )*
{ return rightJoinOperators(o, os), nil }

LogicExpr2
	= op:NotOperator _ s:LogicExpr2
	{ return opSetTarget(op, s), nil }
	/ LogicExpr1

LogicExpr1
	= o:ArithmeticExpr os:( _ l:LogicExpr1Op { return l, nil } )*
{ return rightJoinOperators(o, os), nil }

LogicExpr1Op
	= LogicExpr1In
	/ LogicExpr1Null
	/ LogicExpr1Like
	/ LogicExpr1Cmp

LogicExpr1In
	= n:( t:NotOperator _ { return t, nil } )? InToken _ '(' _ s:MultiExpr _ ')'
{
	op := opSetSubject(&ast.InOperatorNode{}, s)
	if n != nil {
		return opSetTarget(n, op), nil
	}
	return op, nil
}

LogicExpr1Null
	= IsToken n:( _ t:NotOperator { return t, nil } )? _ NullToken
{
	op := opSetSubject(&ast.IsOperatorNode{}, ast.NullValueNode{})
	if n != nil {
		return opSetTarget(n, op), nil
	}
	return op, nil
}

LogicExpr1Like
	= n:( t:NotOperator _ { return t, nil } )? LikeToken _ s:Expr
{
	op := opSetSubject(&ast.LikeOperatorNode{}, s)
	if n != nil {
		return opSetTarget(n, op), nil
	}
	return op, nil
}

LogicExpr1Cmp
	= op:CmpOperator _ s:ArithmeticExpr
{ return opSetSubject(op, s), nil }

ArithmeticExpr
	= ArithmeticExpr3

ArithmeticExpr3
	= o:ArithmeticExpr2 os:( _ op:ConcatOperator _ s:ArithmeticExpr2 { return opSetSubject(op, s), nil } )*
{ return rightJoinOperators(o, os), nil }

ArithmeticExpr2
	= o:ArithmeticExpr1 os:( _ op:AddSubOperator _ s:ArithmeticExpr1 { return opSetSubject(op, s), nil } )*
{ return rightJoinOperators(o, os), nil }

ArithmeticExpr1
	= o:Operand os:( _ op:MulDivModOperator _ s:Operand { return opSetSubject(op, s), nil } )*
{ return rightJoinOperators(o, os), nil }

MultiExpr
	= x:Expr xs:( _ SeparatorToken _ e:Expr { return e, nil } )*
{ return prepend(x, xs), nil }

MultiExprWithDefault
	= x:ExprWithDefault xs:( _ SeparatorToken _ e:ExprWithDefault { return e, nil } )*
{ return prepend(x, xs), nil }

Operand
	= op:UnaryOperator _ s:Operand { return opSetTarget(op, s), nil }
	/ '(' _ e:Expr _ ')' { return e, nil }
	/ &(CastToken) t:TypeCast { return t, nil }
	/ FunctionCall
	/ Value
	/ Identifier

TypeCast
	= CastToken _ '(' _ o:Expr _ AsToken _ s:DataType _ ')'
{ return opSetSubject(opSetObject(&ast.CastOperatorNode{}, o), s), nil }

FunctionCall
	= i:Identifier _ '(' _ r:FunctionArgs? _ ')'
{ return opSetSubject(opSetObject(&ast.FunctionOperatorNode{}, i), r), nil }

FunctionArgs
	= a:AnyLiteral { return []interface{}{a}, nil }
	/ MultiExpr

Assignment
	= i:Identifier _ '=' _ e:ExprWithDefault
{ return opSetSubject(opSetObject(&ast.AssignOperatorNode{}, i), e), nil }

/* Operators */
UnaryOperator
	= SignOperator

SignOperator
	= Sign
{
	switch string(c.text) {
	case "+":
		return &ast.PosOperatorNode{}, nil
	case "-":
		return &ast.NegOperatorNode{}, nil
	}
	panic(fmt.Sprintf("unknown sign %s", c.text))
}

NotOperator
	= NotToken
{ return &ast.NotOperatorNode{}, nil }

AndOperator
	= AndToken
{ return &ast.AndOperatorNode{}, nil }

OrOperator
	= OrToken
{ return &ast.OrOperatorNode{}, nil }

CmpOperator
	= ( "<=" / ">=" / "<>" / "!=" / [<>=] )
{
	switch string(c.text) {
	case "<=":
		return &ast.LessOrEqualOperatorNode{}, nil
	case ">=":
		return &ast.GreaterOrEqualOperatorNode{}, nil
	case "<>":
		return &ast.NotEqualOperatorNode{}, nil
	case "!=":
		return &ast.NotEqualOperatorNode{}, nil
	case "<":
		return &ast.LessOperatorNode{}, nil
	case ">":
		return &ast.GreaterOperatorNode{}, nil
	case "=":
		return &ast.EqualOperatorNode{}, nil
	}
	panic(fmt.Sprintf("unknown comparison operator %s", c.text))
}

ConcatOperator
	= "||"
{ return &ast.ConcatOperatorNode{}, nil }

AddSubOperator
	= [+-]
{
	switch string(c.text) {
	case "+":
		return &ast.AddOperatorNode{}, nil
	case "-":
		return &ast.SubOperatorNode{}, nil
	}
	panic(fmt.Sprintf("unknown addition or subtraction operator %s", c.text))
}

MulDivModOperator
	= [*/%]
{
	switch string(c.text) {
	case "*":
		return &ast.MulOperatorNode{}, nil
	case "/":
		return &ast.DivOperatorNode{}, nil
	case "%":
		return &ast.ModOperatorNode{}, nil
	}
	panic(fmt.Sprintf("unknown multiplication, division, modulo operator: %s", c.text))
}

/* Types */
DataType
	= UIntType
	/ IntType
	/ UFixedType
	/ FixedType
	/ FixedBytesType
	/ DynamicBytesType
	/ BoolType
	/ AddressType

UIntType
	= "UINT"i s:NonZeroLeadingInteger !NormalIdentifierRest
{
	node := ast.IntTypeNode{Unsigned: true}
	size, code := toUint(s.([]byte))
	if code != errors.ErrorCodeNil {
		err := errors.Error{
			Position: uint32(c.pos.offset),
			Category: errors.ErrorCategoryGrammar,
			Code:     code,
			Token:    string(c.text),
			Prefix:   "UIntType",
			Message:  fmt.Sprintf("cannot parse %s as uint32: %v", s, code),
		}
		return node, err
	}
	node.Size = size
	return node, nil
}

IntType
	= "INT"i s:NonZeroLeadingInteger !NormalIdentifierRest
{
	node := ast.IntTypeNode{Unsigned: false}
	size, code := toUint(s.([]byte))
	if code != errors.ErrorCodeNil {
		err := errors.Error{
			Position: uint32(c.pos.offset),
			Category: errors.ErrorCategoryGrammar,
			Code:     code,
			Token:    string(c.text),
			Prefix:   "IntType",
			Message:  fmt.Sprintf("cannot parse %s as uint32: %v", s, code),
		}
		return node, err
	}
	node.Size = size
	return node, nil
}

UFixedType
	= "UFIXED"i s:NonZeroLeadingInteger "X"i t:NonZeroLeadingInteger !NormalIdentifierRest
{
	node := ast.FixedTypeNode{Unsigned: true}
	size, code := toUint(s.([]byte))
	if code != errors.ErrorCodeNil {
		err := errors.Error{
			Position: uint32(c.pos.offset),
			Category: errors.ErrorCategoryGrammar,
			Code:     code,
			Token:    string(c.text),
			Prefix:   "UFixedType",
			Message:  fmt.Sprintf("cannot parse %s as uint32: %v", s, code),
		}
		return node, err
	}
	fractionalDigits, code := toUint(t.([]byte))
	if code != errors.ErrorCodeNil {
		err := errors.Error{
			Position: uint32(c.pos.offset),
			Category: errors.ErrorCategoryGrammar,
			Code:     code,
			Token:    string(c.text),
			Prefix:   "UFixedType",
			Message:  fmt.Sprintf("cannot parse %s as uint32: %v", t, code),
		}
		return node, err
	}
	node.Size = size
	node.FractionalDigits = fractionalDigits
	return node, nil
}

FixedType
	= "FIXED"i s:NonZeroLeadingInteger "X"i t:NonZeroLeadingInteger !NormalIdentifierRest
{
	node := ast.FixedTypeNode{Unsigned: false}
	size, code := toUint(s.([]byte))
	if code != errors.ErrorCodeNil {
		err := errors.Error{
			Position: uint32(c.pos.offset),
			Category: errors.ErrorCategoryGrammar,
			Code:     code,
			Token:    string(c.text),
			Prefix:   "FixedType",
			Message:  fmt.Sprintf("cannot parse %s as uint32: %v", s, code),
		}
		return node, err
	}
	fractionalDigits, code := toUint(t.([]byte))
	if code != errors.ErrorCodeNil {
		err := errors.Error{
			Position: uint32(c.pos.offset),
			Category: errors.ErrorCategoryGrammar,
			Code:     code,
			Token:    string(c.text),
			Prefix:   "FixedType",
			Message:  fmt.Sprintf("cannot parse %s as uint32: %v", t, code),
		}
		return node, err
	}
	node.Size = size
	node.FractionalDigits = fractionalDigits
	return node, nil
}

FixedBytesType
	= "BYTES"i s:NonZeroLeadingInteger !NormalIdentifierRest
{
	node := ast.FixedBytesTypeNode{}
	size, code := toUint(s.([]byte))
	if code != errors.ErrorCodeNil {
		err := errors.Error{
			Position: uint32(c.pos.offset),
			Category: errors.ErrorCategoryGrammar,
			Code:     code,
			Token:    string(c.text),
			Prefix:   "FixedBytesType",
			Message:  fmt.Sprintf("cannot parse %s as uint32: %v", s, code),
		}
		return node, err
	}
	node.Size = size
	return node, nil
}
	/ "BYTE"i !NormalIdentifierRest
{
	return ast.FixedBytesTypeNode{Size: 1}, nil
}

DynamicBytesType
	= ( "BYTES"i !NormalIdentifierRest
		/ "STRING"i !NormalIdentifierRest
		/ "TEXT"i !NormalIdentifierRest
	)
{ return ast.DynamicBytesTypeNode{}, nil }

AddressType
	= "ADDRESS"i !NormalIdentifierRest
{ return ast.AddressTypeNode{}, nil }

BoolType
	= ( "BOOL"i !NormalIdentifierRest
		/ "BOOLEAN"i !NormalIdentifierRest
	)
{ return ast.BoolTypeNode{}, nil }

/* Values */
Value
	= NumberLiteral
	/ StringLiteral
	/ BoolLiteral
	/ NullLiteral

AnyLiteral
	= AnyToken
{ return ast.AnyValueNode{}, nil }

DefaultLiteral
	= DefaultToken
{ return ast.DefaultValueNode{}, nil }

BoolLiteral
	= b:( TrueToken / FalseToken )
{ return ast.BoolValueNode{V: string(b.([]byte)) == "true"}, nil }

NullLiteral
	= NullToken
{ return ast.NullValueNode{}, nil }

NumberLiteral
	= &("0" "X"i) h:Hex { return h, nil }
	/ Decimal

Sign
	= [-+]

Integer
	= [0-9]+
{
	node := ast.IntegerValueNode{IsAddress: false, V: decimal.Zero}
	v, code := toDecimal(c.text)
	if code != errors.ErrorCodeNil {
		err := errors.Error{
			Position: uint32(c.pos.offset),
			Category: errors.ErrorCategoryGrammar,
			Code:     code,
			Token:    string(c.text),
			Prefix:   "Integer",
			Message:  fmt.Sprintf("cannot parse %s as decimal: %v", c.text, code),
		}
		return node, err
	}
	node.V = v
	return node, nil
}

NonZeroLeadingInteger
	= ( "0" / [1-9][0-9]* )
{ return c.text, nil }

Fixnum
	= Integer "." Integer
	/ Integer "."?
	/ "." Integer

Decimal
	= Fixnum ( "E"i Sign? Integer )?
{
	node := ast.DecimalValueNode{V: decimal.Zero}
	v, code := toDecimal(c.text)
	if code != errors.ErrorCodeNil {
		err := errors.Error{
			Position: uint32(c.pos.offset),
			Category: errors.ErrorCategoryGrammar,
			Code:     code,
			Token:    string(c.text),
			Prefix:   "Decimal",
			Message:  fmt.Sprintf("cannot parse %s as decimal: %v", c.text, code),
		}
		return node, err
	}
	node.V = v
	return node, nil
}

Hex
	= "0" "X"i s:( [0-9A-Fa-f] )+ !NormalIdentifierRest
{ return hexToInteger(joinBytes(s)), nil }

StringLiteral
	= HexString
	/ NormalString

HexString
	= ( "HEX"i / "X"i ) "'" s:([0-9a-fA-F][0-9a-fA-F] { return c.text, nil } )* "'"
{ return ast.BytesValueNode{V: hexToBytes(joinBytes(s))}, nil }

NormalString
	= "'" s:( ( [^'\r\n\\] / "\\" . ) { return c.text, nil } )* "'"
{ return ast.BytesValueNode{V: resolveString(joinBytes(s))}, nil }

/* Tokens */
SelectToken
	= "SELECT"i !NormalIdentifierRest

FromToken
	= "FROM"i !NormalIdentifierRest

WhereToken
	= "WHERE"i !NormalIdentifierRest

OrderToken
	= "ORDER"i !NormalIdentifierRest

ByToken
	= "BY"i !NormalIdentifierRest

GroupToken
	= "GROUP"i !NormalIdentifierRest

LimitToken
	= "LIMIT"i !NormalIdentifierRest

OffsetToken
	= "OFFSET"i !NormalIdentifierRest

UpdateToken
	= "UPDATE"i !NormalIdentifierRest

SetToken
	= "SET"i !NormalIdentifierRest

DeleteToken
	= "DELETE"i !NormalIdentifierRest

InsertToken
	= "INSERT"i !NormalIdentifierRest

IntoToken
	= "INTO"i !NormalIdentifierRest

ValuesToken
	= "VALUES"i !NormalIdentifierRest

CreateToken
	= "CREATE"i !NormalIdentifierRest

TableToken
	= "TABLE"i !NormalIdentifierRest

IndexToken
	= "INDEX"i !NormalIdentifierRest

UniqueToken
	= "UNIQUE"i !NormalIdentifierRest

DefaultToken
	= "DEFAULT"i !NormalIdentifierRest

PrimaryToken
	= "PRIMARY"i !NormalIdentifierRest

KeyToken
	= "KEY"i !NormalIdentifierRest

ReferencesToken
	= "REFERENCES"i !NormalIdentifierRest

AutoincrementToken
	= "AUTOINCREMENT"i !NormalIdentifierRest

OnToken
	= "ON"i !NormalIdentifierRest

TrueToken
	= "TRUE"i !NormalIdentifierRest
{ return toLower(c.text), nil }

FalseToken
	= "FALSE"i !NormalIdentifierRest
{ return toLower(c.text), nil }

NullToken
	= "NULL"i !NormalIdentifierRest

IsToken
	= "IS"i !NormalIdentifierRest

NullsToken
	= "NULLS"i !NormalIdentifierRest

LastToken
	= "LAST"i !NormalIdentifierRest
{ return toLower(c.text), nil }

FirstToken
	= "FIRST"i !NormalIdentifierRest
{ return toLower(c.text), nil }

AndToken
	= "AND"i !NormalIdentifierRest

OrToken
	= "OR"i !NormalIdentifierRest

NotToken
	= "NOT"i !NormalIdentifierRest

InToken
	= "IN"i !NormalIdentifierRest

LikeToken
	= "LIKE"i !NormalIdentifierRest

AscToken
	= "ASC"i !NormalIdentifierRest
{ return toLower(c.text), nil }

DescToken
	= "DESC"i !NormalIdentifierRest
{ return toLower(c.text), nil }

CastToken
	= "CAST"i !NormalIdentifierRest

AsToken
	= "AS"i !NormalIdentifierRest

SeparatorToken
	= ","

AnyToken
	= "*"

/* Identifiers */
Identifier
	= NormalIdentifier
	/ StringIdentifier

NormalIdentifier
	= NormalIdentifierStart NormalIdentifierRest*
{ return ast.IdentifierNode{Name: c.text}, nil }

NormalIdentifierStart
	= [a-zA-Z@#_\u0080-\uffff]

NormalIdentifierRest
	= [a-zA-Z0-9@#$_\u0080-\uffff]

StringIdentifier
	= "\"" s:( ( [^"\r\n\\] / "\\" . ) { return c.text, nil } )* "\""
{
	return ast.IdentifierNode{Name: resolveString(joinBytes(s))}, nil
}

/* Skip */
_
	= ( Whitespace / Newline )*

Newline
	= "\r\n"
	/ "\r"
	/ "\n"

Whitespace
	= " "
	/ "\t"
	/ "\v"
	/ "\f"

EOF
	= !.
